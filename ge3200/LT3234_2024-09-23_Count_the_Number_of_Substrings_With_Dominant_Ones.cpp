
#include "../header/myheader.h"

class LT3234
{
public:



    // hint D

    // haha, square = -sqrt...

    // forfor，只不过内层for的 步长， 直接根据 现有的 1 计算出来。 就是 现有 5个1，那么 长度至少可以是 7。  但 似乎步长不够长。。 感觉上还是会tle。  还有其他的， 如果 0*0 > 1，那么直接 + 0*0-1-1
    // 直接跳到 下一次 可能满足的 最大 结尾。
    // 但是中间的值怎么算的？
    // 是直接跳到 能打破 当前状态的 下标。  现在是 符合的，那么 根据现有cnt1，直接计算 最大长度，然后 判断是否 满足，满足就继续 根据 更新后的 cnt1 计算最大可能长度
    // 如果不满足， 那么根据 现有cnt0，计算最大的 不满足的 substr的 结尾。


    // cnt1 >= sqrt(substr.0.cnt)
    // 1
    // 01,10
    // 110,111 permutation
    // 1111,1110,1100,
    // 11100   11000
    // 110000
    // 1110000
    // 111 000 000 000
    // 1111 0000 0000 0000 0000
    // 这能有什么规律？
    // 取反也没有什么意义吧。
    int numberOfSubstrings(string s) {
        
    }


};

int main()
{

    LT3234 lt;


    return 0;
}
