
#include "../header/myheader.h"

class LT1595
{
public:




    // 取最小。。不行的。 a 没有和 对方相连，  a-1 是 2， a-3 是 3， 如果取最小，那就是 a-1， 但是 如果 1 已经其它点被 指向了
    //      3 没有，并且3 只和a相连(或者是 3 和 非a 的点 都是 INT_MAX )，  那么 肯定是 取 a-3 是最小的。
    // 12个，硬算啊。 从最小的开始取。 12^12 ...
    // 或者 一侧是全部， 一侧只取一个。。 然后 一侧 取2个。
    // bu, uf， 如果 上面的 1 已经被选取了，那么 所有 和 1 相连的 边 都可以删除。  然后 最短边 就是 a-3 ?
    // 不不不，一直找 2侧 都没有被连接的，会有问题的。  可能所有的 a 侧的边 和 1都是 1的距离。
    // 感觉还是 一侧全部，一侧 一个一个加？  还是 for for ？
    // 或者 距离 升序。 如果这个 边 的 任意一侧 的点 还没有 被连接。那么就加入进来。
    //      如果 这个边 2侧 都有了， 且 这个边 <=  .. 不行，连锁反应，可能会一路都。。不过才12个。。。
    // int >0 connect  == 0 no connect    | (1<<x)
    // for for 1-1 只有一种， 1-2，只有一种， 1-3只有一种。  1-x只有一种
    //      2-1 只有一种， 2-2 (1-1 + 1-1, 2-1 + ?-1, 2-1 + ?-1, 1-1 + 1-1)
    // 4种，
    // 增加一个， 那么就 分组， 随机提取一个 作为一组， 剩余作为一组， 然后 对方也是 。 
    //            不，对方不需要， (x-1) - (y) 在前面 算过了。
    //              加一个的话，只需要加 它的min 就可以了。 不需要考虑其它，因为对方的(y) 已经全部连接了。
    // {a,b} - {1,2,3,4,5}  {a}-{1,2,3} + {b}-{4,5}  {a}-{1,2,4} + {b}-{3,5}  {a}-{1,2,3,4,5} + {b}-{min} (??)
    // ...状态叠加的。。。{1,2,3,4,5} {1,3,4},{1,3,5},{1,2,5} ...
    int lt1595a(vector<vector<int>>& cost)
    {
        int sz1 = cost.size(), sz2 = cost[0].size();
        for (int i = 0; i < sz1; ++i)
        {
            for ()
        }
    }

};

int main()
{

    LT1595 lt;


    return 0;
}
